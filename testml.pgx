%grammar testml
%version 0.0.1
%include atom

testml_document:
  code_section
  data_section?

# General Tokens
escape: / [0nt] /
line: / ANY* EOL /
blanks: / BLANK+ /
blank_line: / BLANK* EOL /
comment: / '#' line /
ws: /(: BLANK | EOL | comment )/

# Strings
quoted_string:
  | single_quoted_string
  | double_quoted_string

single_quoted_string:
  /(:
    SINGLE
    ((:
      [^ BREAK BACK SINGLE ] |
      BACK SINGLE |
      BACK BACK
    )*?)
    SINGLE
  )/

double_quoted_string:
  /(:
    DOUBLE
    ((:
      [^ BREAK BACK DOUBLE] |
      BACK DOUBLE |
      BACK BACK |
      BACK escape
    )*?)
    DOUBLE
  )/

unquoted_string:
  /(
    [^ BLANKS BREAK HASH]
    (:
      [^ BREAK HASH]*
      [^ BLANKS BREAK HASH]
    )?
  )/

number: / ( DIGIT+ ) /


# TestML Code Section
code_section: (
  | +
  | assignment_statement
  | code_statement
)*

assignment_statement:
  variable_name
  / WS+ '=' WS+ /
  code_expression
  ending

variable_name: /( ALPHA WORD* )/

code_statement:
  code_expression
  assertion_call?
  ending

ending: /(: ';' | EOL )/ | =ending2

ending2: /- '}'/

code_expression:
  code_object
  call_call*

call_call:
  !assertion_call_test
  call_indicator
  code_object

code_object:
  | function_object
  | point_object
  | string_object
  | number_object
  | call_object

function_object:
  function_signature?
  function_start
  ( + | assignment_statement | code_statement )*
  /- '}'/

function_start: /- ( '{' ) -/

function_signature:
  /'(' -/
  function_variables?
  /- ')'/

function_variables:
  function_variable+ % /- ',' -/

function_variable: /( ALPHA WORD* )/

point_object: /( '*' LOWER WORD* )/

string_object: quoted_string

number_object: number

call_object:
  call_name
  call_argument_list?

call_name: user_call | core_call

user_call: /( LOWER WORD* )/

core_call: /( UPPER WORD* )/

call_indicator: /(: '.' - | - '.' )/

call_argument_list:
  /'(' -/
  call_argument* % /- ',' -/
  /- ')'/

call_argument: code_expression

assertion_call_test: / call_indicator (:EQ|OK|HAS) /

assertion_call:
  | +assertion_eq
  | +assertion_ok
  | +assertion_has

assertion_eq:
  | +assertion_operator_eq
  | +assertion_function_eq

assertion_operator_eq:
  /+ '==' +/
  code_expression

assertion_function_eq:
  / call_indicator 'EQ(' /
  code_expression
  / ')' /

assertion_ok: assertion_function_ok

assertion_function_ok: / call_indicator ('OK') empty_parens? /

assertion_has: +assertion_operator_has | +assertion_function_has

assertion_operator_has:
  /+ '~~' +/
  code_expression

assertion_function_has:
  / call_indicator 'HAS(' /
  code_expression
  / ')' /

empty_parens: /(: '(' - ')' )/

# TestML Data Section
block_marker: '==='
point_marker: '---'

data_section: data_block*

data_block:
  block_header
  .( blank_line | comment )*
  block_point*

block_header:
  block_marker
  ( blanks block_label )?
  blank_line

block_label: unquoted_string

block_point: lines_point | phrase_point

lines_point:
  point_marker
  blanks
  point_name
  blank_line
  point_lines

point_lines: /(
  (:
    (!
      block_marker |
      point_marker
    )
    line
  )*
)/

phrase_point:
  point_marker
  blanks
  point_name
  / COLON BLANK /
  point_phrase
  / EOL /
  /(:
    comment |
    blank_line
  )*/

point_name:
  /(
    user_point_name |
    core_point_name
  )/

user_point_name:  / LOWER WORD* /

core_point_name:  / UPPER WORD* /

point_phrase: unquoted_string

# vim: sw=2:
